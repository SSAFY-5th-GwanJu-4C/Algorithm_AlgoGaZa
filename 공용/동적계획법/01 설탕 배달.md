# 설탕 배달
## 점화식 세우기 위한 과정(생각)     
      
문제를 읽어보면 아래와 같은 사항을 도출할 수 있다.   

* 3과 5로 만들 수 없는 수는 -1로 출력 
* 3과 5로 만들 수 있는 수 있다면 조합 갯수의 최소 값을 출력
   
즉, 현재에 있던 값이 3과 5의 조합으로 이루어져야 하며    
이전에 있던 값이 -1이면 안 된다는 조건을 알 수 있다.      

그리고 동적계획법의 특징인 **단계** 를 생각해보자   

* 11 = 3+3+5는 11이다.
* 11 = 5+5+3은 11이다. 

이를 아래와 같이 풀어보겠다.  

* 11-3 = 3+5
* 11-5 = 5+3

그럼 다시 본론으로 들어와서 우리가 동적 계획법으로 표현하고자 하는 값을 알아보자         
n 만큼의 값이 들어왔을 때의 이동거리 최솟갑이므로 아래와 같은 형태가 될 것을 예상한다.    
    
* `d[n] = 움직임의 최솟값`   

그리고 움직임은 3이나 5를 더할 때마다 1씩 증가된다.      

이제 여기서 도출된 내용들을 가지고 점화식을 세워보자   

## 점화식 세우기  

```c++
d[n-3] = d[n-3]+1;
d[n-5] = d[n-5]+1;
```
단, `이전에 있던 값이 -1이면 안 된다`는 제한 조건이 있었다.   

```c++
if(d[n-3] != -1) d[n-3] = d[n-3]+1;
if(d[n-5] != -1) d[n-5] = d[n-5]+1;
```

사실,  
`if(d[n-3] != -1 && d[i] > d[i-3]+1)`와 같은 형태로 작성해야지만,  
5로 계산한 값은 3보다 무조건 작으므로 순서로 최솟값을 조정했다.   

```c++
if(d[n-5] != -1) d[n-5] = d[n-5]+1;
if(d[n-3] != -1) d[n-3] = d[n-3]+1;
```
당연한 얘기지만 위와 같이 하면 값이 안나온다.   

이를 활용해서 문제를 풀면 아래와 같다.  

## 문제풀이 C++
```c++
#include <iostream>
#include <algorithm>
using namespace std;

int d[5001];
int main(){
    cin.tie(NULL);
    ios::sync_with_stdio(false);
    
    int n; cin >> n;
    
    d[0] = -1;
    d[1] = -1;
    d[2] = -1;
    d[3] = 1;
    d[4] = -1;
    d[5] = 1;
    
    for(int i=6; i <= n; i++){
        d[i] = -1;
        if(i%3 == 0 || d[i-3] != -1) d[i] = d[i-3]+1;
        if(i%5 == 0 || d[i-5] != -1) d[i] = d[i-5]+1;
    }
    
    cout << d[n] << "\n";
    return 0;
}

```
